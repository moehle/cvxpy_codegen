/*
 *  Copyright 2017 Nicholas Moehle
 *  
 *  This file is part of CVXPY-CODEGEN.
 *  
 *  CVXPY-CODEGEN is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  CVXPY-CODEGEN is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with CVXPY-CODEGEN.  If not, see <http://www.gnu.org/licenses/>.
 */

{% from 'solvers/'+solver_name+"_intf.c.jinja" import solver_workspace with context %}
{% from expr_handler_c_jinja import expr_handler_workspace with context %}
#ifndef CVXPY_CODEGEN
#define CVXPY_CODEGEN

{% if include_solver %}
#include "{{ solver_name }}.h"
{% endif %}


/* Exit codes: */
#define CG_OPTIMAL     (0)
#define CG_INFEASIBLE  (1)
#define CG_UNBOUNDED   (2)
#define CG_SOLVER_ERR  (3)


typedef struct params_struct{
    {% for p in named_params -%}
    {{ p.c_print_struct() }}
    {% endfor %}
} Params;


typedef struct vars_struct{
    {% for v in named_vars %}
    {{ v.c_print_struct() }}
    {% endfor %}
} Vars;


typedef struct csr_matrix{
    long *p;
    long *j;
    double *x;
    long m;
    long n;
    long nnz;
} CsrMatrix;


typedef struct csc_matrix{
    long *p;
    long *i;
    double *x;
    long m;
    long n;
    long nnz;
} CscMatrix;


typedef struct linop_coeff{
    long *p;
    long *j;
    double *x;
    long m;
    long n;
    long nnz;
    long m_var; /* Shape of the represented variable. */
    long n_var; /* Note that m_var * n_var = m. */
} LinopCoeff;


typedef struct work_struct{

    /* Results. */
    double *primal_var;
    double *dual_eq_var;
    double *dual_ineq_var;
    double optval;
    int status;  /* Also returned by cg_solve. */
    long solver_flag;

    /* Variables used by the solver. */
    {{ solver_workspace(include_solver=include_solver) }}

    {{ expr_handler_workspace() }}

    /* Storage for integer and double workspaces. */
    long work_int[{{ work_int }}];
    double work_double[{{ work_float }}];
    CsrMatrix work_varargs[{{ work_varargs }}];
    LinopCoeff work_coeffs[{{ work_coeffs }}];
} Work;


/* Initializes the workspace.  The pointer 'work' must point
 * to a (possibly uninitialized) block of memory with enough
 * space to hold a 'Work' structure.
 * Depending on the solver used, this function may require
 * dynamic memory allocation.
 */
void cg_init(Work *work);


/* Solves the problem.
 * Requires no dynamic memory allocation (and performs no cleanup.)
 * Returns an integer exit code, with values defined at the
 * beginning of this header file.
 *
 * INPUTS:
 * work     - Pointer to a Work workspace that has been initialized
 *            using the using the 'cg_init' function above.
 * params   - Pointer to a Params structure with values initialized 
 *            by the user.
 *
 * OUTPUTS:
 * vars     - Pointer to a Vars structure.  The values in this struct
 *            are uninitialized on input.  On output, they contain
 *            the problem solution.
 */
int cg_solve(Params *params, Work *work, Vars *vars);


/* Deallocates all memory allocated in 'cg_init'.
 * If, for a given solver, 'cg_init' does not require
 * dynamic memory allocation, this function does nothing.
 */
void cg_cleanup(Work *work);


#endif
