/*
 *  Copyright 2017 Nicholas Moehle
 *  
 *  This file is part of CVXPY-CODEGEN.
 *  
 *  CVXPY-CODEGEN is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  CVXPY-CODEGEN is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with CVXPY-CODEGEN.  If not, see <http://www.gnu.org/licenses/>.
 */

{% import "utils/utils.c.jinja" as u with context %}
#include "codegen.h"
{% if include_solver %}
#include "ecos.h"
{% endif %}
#include <math.h>
#include <stdio.h> // TODO


{{ u.print_cscmat_declare() }}
{{ u.print_vec_declare() }}


{% macro solver_workspace(include_solver=True) -%}
    
    {% if include_solver %}
    pwork *solver_work;
    {% endif %}

    {#
    /* Problem coefficients. */

    /* Storage for the equality constraints. */
    CscMatrix eq_coeff;
    double eq_nzval[{{ eq_coeff.nnz }}];
    double eq_offset[{{ eq_dim }}];

    /* Storage for the inequality constraints. */
    CscMatrix leq_coeff;
    double leq_nzval[{{ leq_coeff.nnz }}];
    double leq_offset[{{ cone_dim }}];

    /* Storage for the objective vector. */
    CscMatrix obj_coeff;
    double obj_nzval[{{ obj_coeff.nnz }}];
    double obj_vec[{{ x_length }}];
    double obj_offset;
    #}
{%- endmacro %}


/* Sparsity pattern for the objective and constraint matrices. */
{#
long obj_colptr{{ u.print_vec(obj_coeff.indptr) }};
long obj_rowidx{{ u.print_vec(obj_coeff.indices) }};
long eq_colptr{{ u.print_vec(eq_coeff.indptr) }};
long eq_rowidx{{ u.print_vec(eq_coeff.indices) }};
long leq_colptr{{ u.print_vec(leq_coeff.indptr) }};
long leq_rowidx{{ u.print_vec(leq_coeff.indices) }};
#}




static long soc_sizes{{ u.print_vec(soc_dims) }};


/* Initialize ECOS. */
void solver_init(Work *work){

    {#
    work->eq_coeff.p = eq_colptr;
    work->eq_coeff.i = eq_rowidx;
    work->eq_coeff.x = work->eq_nzval;
    work->eq_coeff.m = {{ eq_coeff.shape[0] }};
    work->eq_coeff.n = {{ eq_coeff.shape[1] }};
    work->eq_coeff.nnz = {{ eq_coeff.nnz }};

    work->leq_coeff.p = leq_colptr;
    work->leq_coeff.i = leq_rowidx;
    work->leq_coeff.x = work->leq_nzval;
    work->leq_coeff.m = {{ leq_coeff.shape[0] }};
    work->leq_coeff.n = {{ leq_coeff.shape[1] }};
    work->leq_coeff.nnz = {{ leq_coeff.nnz }};

    work->obj_coeff.p = obj_colptr;
    work->obj_coeff.i = obj_rowidx;
    work->obj_coeff.x = work->obj_nzval;
    work->obj_coeff.m = {{ obj_coeff.shape[0] }};
    work->obj_coeff.n = {{ obj_coeff.shape[1] }};
    work->obj_coeff.nnz = {{ obj_coeff.nnz }};
    work->obj_offset = 0;
    #}


    /* Zero out the floating point values to avoid numerical difficulties. */
    long p;
    for (p=0; p<work->eq_coeff.nnz; p++)  work->eq_coeff.x[p] = 0;
    for (p=0; p<work->leq_coeff.nnz; p++)  work->leq_coeff.x[p] = 0;

    {% if include_solver %}
    work->solver_work = ECOS_setup({{ x_length }}, {{ cone_dim }}, {{ eq_dim }},
             {{ leq_dim }}, {{ len(soc_dims) }}, soc_sizes, {{ exp_cones }}, 
             work->leq_coeff.x, work->leq_coeff.p, work->leq_coeff.i,
             work->eq_coeff.x, work->eq_coeff.p, work->eq_coeff.i,
             work->obj_coeff, work->leq_offset, work->eq_offset);
    {% endif %}

}





/* Solve the problem using ECOS. */
void solver_solve(Work *work){


    {% if include_solver %}
    idxint solver_flag;
    
    {{ u.print_cscmat_eval('eq_coeff') }}
    {{ u.print_vec_eval('eq_offset', eq_dim ) }}
    {{ u.print_cscmat_eval('leq_coeff') }}
    {{ u.print_vec_eval('leq_offset', cone_dim) }}
    {{ u.print_vec_eval('obj_coeff', x_length) }}
    printf("obj_offset = %f\n", work->obj_offset);

    /* Flip signs. */
    long i;
    for (i=0; i<work->eq_coeff.m; i++)  work->eq_offset[i] *= -1;
    for (i=0; i<work->leq_coeff.m; i++)  work->leq_offset[i] *= -1;

    ECOS_updateData(work->solver_work, work->leq_nzval, work->eq_nzval,
                     work->obj_coeff, work->leq_offset, work->eq_offset);

    solver_flag = ECOS_solve(work->solver_work);

    work->primal_var = work->solver_work->x;
    work->dual_eq_var = work->solver_work->y;
    work->dual_ineq_var = work->solver_work->z;

    switch(solver_flag){

        case ECOS_OPTIMAL:
        case ECOS_OPTIMAL + ECOS_INACC_OFFSET:
            work->status = CG_OPTIMAL;
            work->optval = work->solver_work->info->pcost + work->obj_offset;
            break;

        case ECOS_PINF:
        case ECOS_PINF + ECOS_INACC_OFFSET:
            work->status = CG_INFEASIBLE;
            work->optval = INFINITY;
            break;
            
        case ECOS_DINF:
        case ECOS_DINF + ECOS_INACC_OFFSET:
            work->status = CG_UNBOUNDED;
            work->optval = -INFINITY;
            break;

        case ECOS_MAXIT:
        case ECOS_NUMERICS:
        case ECOS_OUTCONE:
        case ECOS_SIGINT:
        case ECOS_FATAL:
            work->status = CG_SOLVER_ERR;
            work->optval = NAN;
            break;

    }

    {% endif %}
} 


/* Clean up ECOS memory. */
void cg_cleanup(Work *work){
    {% if include_solver %}
    ECOS_cleanup(work->solver_work, 0);
    {% endif %}
}





{% macro makefile_target() -%}
     libecos.a
{%- endmacro %} 


{{ u.print_cscmat_define() }}

{{ u.print_vec_define() }}
